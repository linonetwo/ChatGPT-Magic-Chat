{"tiddlers":{"$:/plugins/tobibeer/appear/widget.js":{"title":"$:/plugins/tobibeer/appear/widget.js","text":"/*\\\ntitle: $:/plugins/tobibeer/appear/widget.js\ntype: application/javascript\nmodule-type: widget\n\nUse the appear widget for popups, sliders, accordion menus\n\n@preserve\n\\*/\n(function(){\n\n/*jslint node: true, browser: true */\n/*global $tw: false */\n\"use strict\";\n\nvar Widget = require(\"$:/core/modules/widgets/widget.js\").widget,\n\tAppearWidget = function(parseTreeNode,options) {\n\t\tthis.initialise(parseTreeNode,options);\n\t},\n\thandlerCache = {};\n\n/*\nInherit from the base widget class\n*/\nAppearWidget.prototype = new Widget();\n\n/*\nRender this widget into the DOM\n*/\nAppearWidget.prototype.render = function(parent,nextSibling) {\n\tthis.parentDomNode = parent;\n\tthis.nextSibling = nextSibling;\n\tthis.computeAttributes();\n\tthis.execute();\n\tvar cls,button,buttonClose,hidden,reveal,shown,\n\t\t// Will hold the child widgets\n\t\tnodes = [];\n\t// Handler instance?\n\tif(this.handle) {\n\t\t// Recreate cache\n\t\tthis.getHandlerCache(this.handle,1);\n\t\t// Handle refreshes\n\t\tthis.refreshHandler();\n\t// Regular instance\n\t} else {\n\t\t// Create button\n\t\tbutton = {type:\"button\"};\n\t\t// Init button attributes\n\t\tbutton.attributes = this.setAttributes(button,\"button\");\n\t\t// Store current classes\n\t\tcls = button.attributes[\"class\"].value.trim();\n\t\t// Add unselected class\n\t\tbutton.attributes[\"class\"].value = cls + \" appear-show\" + (this.handler ? \" tc-popup-absolute\" : \"\");\n\t\t// Parse label and add to children\n\t\tbutton.children = this.wiki.parseText(\n\t\t\t\"text/vnd.tiddlywiki\",\n\t\t\tthis.show,\n\t\t\t{parseAsInline: true}\n\t\t).tree;\n\t\t// Create reveal\n\t\treveal = {type:\"reveal\",children:this.parseTreeNode.children};\n\t\t// Init reveal attributes\n\t\treveal.attributes = this.setAttributes(reveal,\"reveal\");\n\t\t// Set custom mode, if configured\n\t\treveal.isBlock = !(this.mode && this.mode === \"inline\");\n\t\t// Type popup?\n\t\tif(reveal.attributes.type && reveal.attributes.type.value === \"popup\") {\n\t\t\t// Set button attribute for popup state\n\t\t\tbutton.attributes.popup = reveal.attributes.state;\n\t\t\t// Add childnodes\n\t\t\tnodes.push(button);\n\t\t\t// Unless we have a deferred handler defined\n\t\t\tif(!this.handler) {\n\t\t\t\t// Push reveal to node tree\n\t\t\t\tnodes.push(reveal);\n\t\t\t} else {\n\t\t\t\tbutton.attributes.handler = this.handler;\n\t\t\t}\n\t\t// Not a popup\n\t\t} else {\n\t\t\t// Set reveal attribute for \"slider mode\"\n\t\t\treveal.attributes.type = {type: \"string\", value: \"match\"};\n\t\t\t// Must match current tiddler title\n\t\t\treveal.attributes.text = {type: \"string\", value: this.currentTiddler};\n\t\t\t// Button writes to state tiddler\n\t\t\tbutton.attributes.set =  reveal.attributes.state;\n\t\t\t// Sets to current tiddler\n\t\t\tbutton.attributes.setTo =  {type: \"string\", value: this.currentTiddler};\n\t\t\t// A wrapper reveal that will be hidden once the content is shown containing the button\n\t\t\thidden = {type:\"reveal\",isBlock: this.block, children:[button], attributes: {\n\t\t\t\ttype: {type: \"string\", value: \"nomatch\"},\n\t\t\t\tstate: reveal.attributes.state,\n\t\t\t\ttext: {type: \"string\", value: this.currentTiddler}\n\t\t\t}};\n\t\t\t// Endless toggling?\n\t\t\tif(!this.once) {\n\t\t\t\t// Create hide-button as a copy of the button\n\t\t\t\tbuttonClose = $tw.utils.deepCopy(button);\n\t\t\t\t// Add selected class\n\t\t\t\tbuttonClose.attributes[\"class\"].value = cls + \" appear-hide \" +\n\t\t\t\t\t(this.attr.button.selectedClass ? this.attr.button.selectedClass : \"\");\n\t\t\t\t// However, resetting the state\n\t\t\t\tbuttonClose.attributes.setTo = {type: \"string\", value: \"\"};\n\t\t\t\t// Setting the hide-button label\n\t\t\t\tbuttonClose.children = this.wiki.parseText(\n\t\t\t\t\t\"text/vnd.tiddlywiki\",\n\t\t\t\t\tthis.hide,\n\t\t\t\t\t{parseAsInline: true}\n\t\t\t\t).tree;\n\t\t\t}\n\t\t\t// Create a copy of the first reveal containing the button\n\t\t\tshown = $tw.utils.deepCopy(hidden);\n\t\t\t// Reset its children\n\t\t\tshown.children = [];\n\t\t\t// Endless toggling?\n\t\t\tif(!this.once) {\n\t\t\t\t// Add close button\n\t\t\t\tshown.children.push(buttonClose);\n\t\t\t}\n\t\t\t// No remote handler?\n\t\t\tif(!this.handler) {\n\t\t\t\t// Add slider contents\n\t\t\t\tshown.children.push(reveal);\n\t\t\t}\n\t\t\t// Switch reveal type for content reveal wrapper\n\t\t\tshown.attributes.type.value = \"match\";\n\t\t\t// Add wrapping reveals to output\n\t\t\tnodes.push(hidden,shown);\n\t\t}\n\t\t// Construct the child widgets\n\t\tthis.makeChildWidgets(nodes);\n\t\t// Render into the dom\n\t\tthis.renderChildren(this.parentDomNode,nextSibling);\n\t\t// Now, do we have a remote handler?\n\t\tif(this.handler) {\n\t\t\t// Update its state\n\t\t\tthis.addToHandlerCache(reveal);\n\t\t}\n\t}\n};\n\n/*\nCompute the internal state of the widget\n*/\nAppearWidget.prototype.execute = function() {\n\tvar self = this;\n\t// Attribute mapping\n\tthis.attr = {\n\t\t// Which attributes map to which element\n\t\tmap: {\n\t\t\treveal: {\n\t\t\t\t\"class\":1,\n\t\t\t\tposition:1,\n\t\t\t\tretain:1,\n\t\t\t\tstate:1,\n\t\t\t\tstyle:1,\n\t\t\t\ttag:1,\n\t\t\t\ttype:1\n\t\t\t},\n\t\t\tbutton: {\n\t\t\t\t\"button-class\":1,\n\t\t\t\t\"button-style\":1,\n\t\t\t\t\"button-tag\":1,\n\t\t\t\ttooltip:1,\n\t\t\t\tselectedClass:1\n\t\t\t}\n\t\t},\n\t\t// Rename duplicate attributes later\n\t\trename: {\n\t\t\t\"button-class\":\"class\",\n\t\t\t\"button-style\":\"style\",\n\t\t\t\"button-tag\":\"tag\"\n\t\t},\n\t\t// Initialize empty containers\n\t\tbutton: {},\n\t\treveal: {}\n\t};\n\t// Loop widget attributes\n\t$tw.utils.each(this.attributes,function(val,key) {\n\t\tvar next;\n\t\t// Loop mappings\n\t\t$tw.utils.each(\n\t\t\tself.attr.map,function(attr,el) {\n\t\t\t// Loop attributes for element\n\t\t\t$tw.utils.each(Object.keys(attr),function(attr) {\n\t\t\t\t// Attribute for element?\n\t\t\t\tif(attr == key) {\n\t\t\t\t\t// Store attr value\n\t\t\t\t\tself.attr[el][key] = val;\n\t\t\t\t\t// Next attribute\n\t\t\t\t\tnext = false;\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t});\n\t\t\treturn next;\n\t\t});\n\t});\n\t// Handle all other attributes...\n\t// Store current tiddler\n\tthis.currentTiddler = this.getVariable(\"currentTiddler\");\n\t// Default button label\n\tthis.show = this.getValue(this.attributes.show,\"show\");\n\t// Label for hide-button\n\tthis.hide = this.getValue(this.attributes.hide,\"hide\");\n\t// None defined?\n\tif(!this.hide) {\n\t\t// Use default label\n\t\tthis.hide = this.show;\n\t}\n\t// Whether to only reveal the content once\n\tthis.once = this.attributes.once && this.attributes.once !== \"false\";\n\t// State shorthand\n\tthis.$state = this.attributes.$state;\n\t// Reveal mode\n\tthis.mode = this.getValue(this.attributes.mode,\"mode\");\n\t// Is this a handler instance?\n\tthis.handle = this.attributes.handle;\n\t// Remotely handle this instance?\n\tthis.handler = this.attributes.handler;\n\t// For that case we take these variables along\n\tthis.handlerVariables = (this.attributes.variables || \"\") + \" currentTiddler\";\n\t// Whether or not to keep popups\n\tthis.keep = [\"yes\",\"true\"].indexOf(\n\t\t\t(this.getValue(this.attributes.keep,\"keep\")||\"\").toLocaleLowerCase()\n\t\t) >- 1;\n\t// No explicit state?\n\tif(!this.attr.reveal.state) {\n\t\t// Calculate fallback state\n\t\tthis.attr.reveal.state =\n\t\t\t\tthis.getValue(undefined,\"default-state\") +\n\t\t\t\tthis.currentTiddler +\n\t\t\t\tthis.getStateQualifier() + \"/\" +\n\t\t\t\t(this.attr.reveal.type ? this.attr.reveal.type + \"/\" : \"\") +\n\t\t\t\t(this.mode ? this.mode + \"/\" : \"\") +\n\t\t\t\t(this.once ? \"once/\" : \"\") +\n\t\t\t\t// Append state suffix, if given\n\t\t\t\t(this.$state ? \"/\" + this.$state : \"\");\n\t}\n};\n\n/*\nSelectively refreshes the widget if needed. Returns true if the widget or any of its children needed re-rendering\n*/\nAppearWidget.prototype.refresh = function(changedTiddlers) {\n\tvar changedAttributes = this.computeAttributes();\n\t// Any changed attributes?\n\tif(Object.keys(changedAttributes).length) {\n\t\t// Refresh\n\t\tthis.refreshSelf();\n\t\treturn true;\n\t}\n\t// Global handler?\n\tif(this.handle) {\n\t\t// Handle refreshes\n\t\tthis.refreshHandler();\n\t}\n\t// Check if we're refreshing children\n\treturn this.refreshChildren(changedTiddlers);\n};\n\n/*\nRetrieves a widget parameter as either attribute, config-tiddler default or hard-coded fallback.\n*/\nAppearWidget.prototype.getValue = function(value,attr){\n\tvar def,undef,\n\t\t// Global fallbacks\n\t\tfallbacks = {\n\t\t\tshow: \"Â»\",\n\t\t\t\"default-state\": \"$:/temp/appear/\"\n\t\t};\n\t// If there is no value...\n\tif(value === undefined) {\n\t\t// Get default for it\n\t\tdef = this.wiki.getTiddler(\"$:/plugins/tobibeer/appear/defaults/\" + attr);\n\t\t// Got one?\n\t\tif(def) {\n\t\t\t// Check if set to undefined\n\t\t\tundef = def.getFieldString(\"undefined\");\n\t\t\t// Not undefined?\n\t\t\tif(!undef || undef === \"false\") {\n\t\t\t\t// Read default\n\t\t\t\tvalue = def.getFieldString(\"text\");\n\t\t\t}\n\t\t}\n\t}\n\t// If we still have no value\n\tif(value === undefined) {\n\t\t// Try to read from fallbacks\n\t\tvalue = fallbacks[attr];\n\t}\n\treturn value;\n};\n\n/*\nSet child-widget attributes for a given element,\ndepending on the parsed widget attributes\n*/\nAppearWidget.prototype.setAttributes = function(node,element) {\n\tvar self = this,\n\t\t// Initialize attributes object\n\t\tresult = {};\n\t// Loop attributes defined for this element\n\t$tw.utils.each(Object.keys(this.attr.map[element]),function(attr) {\n\t\tvar val,\n\t\t\t// Check if we needed to rename this attribute\n\t\t\tname = self.attr.rename[attr];\n\t\t// Not renamed?\n\t\tif(!name) {\n\t\t\t// Take attribute name as is\n\t\t\tname = attr;\n\t\t}\n\t\t// Read as widget value, default, or fallback\n\t\tval = self.getValue(self.attr[element][attr],attr);\n\t\t// Class attribute? (always for the button, for the reveal only if undefined)\n\t\tif(name === \"class\") {\n\t\t\t// Construct classes\n\t\t\tval = [\n\t\t\t\t\"appear\",\n\t\t\t\t\"appear-\" + element,\n\t\t\t\t(element === \"reveal\" && self.keep ? \"tc-popup-keep\" : \"\"),\n\t\t\t\t(self.mode ? \"appear-\" + self.mode : \"\"),\n\t\t\t\t(self.once ? \"appear-once\" : \"\"),\n\t\t\t\t(val || \"\")\n\t\t\t].join(\" \");\n\t\t}\n\t\t// Do we have a value?\n\t\tif(val !== undefined) {\n\t\t\t// Set an element tag?\n\t\t\tif(name === \"tag\") {\n\t\t\t\t// Then set it for the parseTreeNode directly\n\t\t\t\tnode.tag = val;\n\t\t\t// Set an attribute?\n\t\t\t} else {\n\t\t\t\t// Add to attribute object\n\t\t\t\tresult[name] = {type: \"string\", value: val};\n\t\t\t}\n\t\t}\n\t});\n\t// Return all attributes as an object\n\treturn result;\n};\n\n/*\nRetrieves handler cache, creates if not existing or told to\n*/\nAppearWidget.prototype.getHandlerCache = function(handler,create) {\n\t// Retrieve cache for handler\n\tvar cache = handlerCache[handler];\n\t// If not existing or asked to be created\n\tif(!cache || create){\n\t\t// Create new cache for handler\n\t\thandlerCache[handler] = {\n\t\t\t// For these states\n\t\t\thandled: {},\n\t\t\t// Refresh list\n\t\t\thandle: {}\n\t\t};\n\t\tcache = handlerCache[handler];\n\t}\n\treturn cache;\n};\n\n/*\nRetrieve notifier list for global handler and create contents accordingly\n*/\nAppearWidget.prototype.refreshHandler = function() {\n\tvar self = this,\n\t\t// Get cache for handler\n\t\tcache = this.getHandlerCache(this.handle),\n\t\t// Load refresh items from global cache for handler\n\t\thandle = cache.handle;\n\t// Got anything to handle?\n\tif(Object.keys(handle).length) {\n\t\t// Loop refresh handles\n\t\t$tw.utils.each(handle, function(node,state) {\n\t\t\t// Remove existing child node\n\t\t\tself.removeChildNode(state);\n\t\t\t// Render as child node\n\t\t\tself.children.push(self.makeChildWidget(node));\n\t\t\t// Rrnder child\n\t\t\tself.children[self.children.length - 1].render(self.parentDomNode,self.nextSibling);\n\t\t});\n\t\t// Remove entries\n\t\thandlerCache[this.handle].handle = {};\n\t}\n};\n\n/*\nRemoves a child node of a handler for a given state\n*/\nAppearWidget.prototype.removeChildNode = function(state) {\n\tvar self = this;\n\t// Loop all child widgets of handler\n\t$tw.utils.each(this.children, function(node,index) {\n\t\t// Same state?\n\t\tif(node.children[0].state === state) {\n\t\t\t// Remove any domNodes\n\t\t\tnode.removeChildDomNodes();\n\t\t\t// Delete child widget\n\t\t\tself.children.splice(index);\n\t\t\t// Done\n\t\t\treturn false;\n\t\t}\n\t});\n};\n\n/*\nChecks and updates the state for a reveal widget handling remote content\n*/\nAppearWidget.prototype.addToHandlerCache = function(reveal) {\n\tvar self = this,\n\t\t// Only one per state\n\t\tstate = reveal.attributes.state.value,\n\t\t// Retrieve cache for handler\n\t\tcache = this.getHandlerCache(this.handler),\n\t\t// Retrieve parseTree for state as cached for the handler\n\t\tcached = cache.handled[state],\n\t\t// Create vars widget wrapper containing the reveal\n\t\tvars = {type:\"vars\", children:[reveal], attributes:{}};\n\t// Loop\n\t$tw.utils.each(\n\t\t// Handler variables\n\t\t(this.handlerVariables || \"\").split(\" \"),\n\t\tfunction(v) {\n\t\t\t// No empty strings\n\t\t\tv = v.trim();\n\t\t\tif(v){\n\t\t\t\t// Store variable as vars widget attribute by...\n\t\t\t\tvars.attributes[v] = {\n\t\t\t\t\ttype: \"string\",\n\t\t\t\t\t// Fetching the current variable value\n\t\t\t\t\tvalue: (self.getVariable(v) || \"\").toString()};\n\t\t\t}\n\t\t}\n\t);\n\t// If the state for this reveal is not the cached one\n\tif(vars !== cached) {\n\t\t// Add to refresh list, picked up by handler\n\t\tcache.handle[state] = vars;\n\t\t// Trigger refresh by writing to dummy temp tiddler for handler\n\t\tthis.wiki.setText(\"$:/temp/appear-handler/\"+this.handler,\"text\",undefined,state);\n\t}\n};\n\n// Now we got a widget ready for use\nexports.appear = AppearWidget;\n\n})();","type":"application/javascript","module-type":"widget"},"$:/plugins/tobibeer/appear/defaults/show":{"title":"$:/plugins/tobibeer/appear/defaults/show","text":"Â»"},"$:/plugins/tobibeer/appear/defaults/mode":{"title":"$:/plugins/tobibeer/appear/defaults/mode","text":"block"},"$:/plugins/tobibeer/appear/defaults/keep":{"title":"$:/plugins/tobibeer/appear/defaults/keep","text":"yes"},"$:/plugins/tobibeer/appear/defaults/button-class":{"title":"$:/plugins/tobibeer/appear/defaults/button-class","text":"tc-btn-invisible tc-tiddlylink"},"$:/plugins/tobibeer/appear/defaults/default-state":{"title":"$:/plugins/tobibeer/appear/defaults/default-state","text":"$:/temp/appear/"},"$:/plugins/tobibeer/appear/popup.js":{"title":"$:/plugins/tobibeer/appear/popup.js","text":"/*\\\ntitle: $:/plugins/tobibeer/appear/popup.js\ntype: application/javascript\nmodule-type: utils\n\nAn enhanced version of the core Popup to support:\n* absolute popups\n* preview popups\n* popup z-index\n\n@preserve\n\\*/\n(function () {\n  /*jslint node: true, browser: true */\n  /*global $tw: false */\n  'use strict';\n\n  const Popup = require('$:/core/modules/utils/dom/popup.js').Popup,\n    Reveal = require('$:/core/modules/widgets/reveal.js').reveal,\n    refreshCoreReveal = Reveal.prototype.refresh;\n\n  const originalShow = Popup.prototype.show;\n\n  /*\n  Hijack and overwrite core Popup show() method\n    => required for absolute popup positioning, rather than relative\n  */\n  Popup.prototype.show = function (options) {\n    // fix https://github.com/tobibeer/tw5-appear/issues/5\n    if (!options.domNode) {\n      return originalShow.call(this, options);\n    }\n    // The button\n    let cancelLevel;\n    let el = options.domNode;\n    // Check if button absolutely positioned\n    let absolute = $tw.utils.hasClass(el, 'tc-popup-absolute');\n    // Find out what was clicked on\n    let info = this.popupInfo(el);\n    // Helper to calculate the absolte offset\n    const calcAbsoluteOffset = function (el) {\n      let e = el;\n\t\t\tlet x = 0;\n\t\t\tlet y = 0;\n      do {\n        x += e.offsetLeft || 0;\n        y += e.offsetTop || 0;\n        e = e.offsetParent;\n      } while (e);\n      return { left: x, top: y };\n    };\n    let offset = {\n      left: el.offsetLeft,\n      top: el.offsetTop,\n    };\n    // Level to be canceled\n    cancelLevel = info.popupLevel;\n    // If we clicked on a handle\n    if (info.isHandle) {\n      // Next level\n      cancelLevel++;\n    }\n    // Cancel any higher level popups\n    this.cancel(cancelLevel);\n    // Store the popup details if not already there\n    if (this.findPopup(options.title) === -1) {\n      // Store the popup details\n      this.popups.push({\n        title: options.title,\n        wiki: options.wiki,\n        domNode: el,\n      });\n    }\n    // Calculate absolute offset?\n    offset = absolute ? calcAbsoluteOffset(el) : offset;\n    // Set the state tiddler\n    options.wiki.setTextReference(options.title, '(' + offset.left + ',' + offset.top + ',' + el.offsetWidth + ',' + el.offsetHeight + ')');\n    // Add the click handler if we have any popups\n    if (this.popups.length > 0) {\n      this.rootElement.addEventListener('click', this, true);\n    }\n  };\n\n  // Hijack popupInfo() of core Popup ($tw.popup)\n  Popup.prototype.popupInfo = function (domNode) {\n    var popupCount,\n      isHandle = false,\n      node = domNode;\n    // First check ancestors to see if we're within a popup handle\n    while (node && popupCount === undefined) {\n      // When\n      if (\n        // This is a handle\n        $tw.utils.hasClass(node, 'tc-popup-handle') ||\n        // Or a sticky popup\n        $tw.utils.hasClass(node, 'tc-popup-keep')\n      ) {\n        // We set this flag (not exactly sure about the general idea here)\n        isHandle = true;\n      }\n      // When\n      if (\n        // It's a reveal\n        $tw.utils.hasClass(node, 'tc-reveal') &&\n        // Being a popup\n        ($tw.utils.hasClass(node, 'tc-popup') ||\n          // Or a popup-handle reveal (the choice of name seems confusing)\n          $tw.utils.hasClass(node, 'tc-popup-handle'))\n      ) {\n        // Calculate popup level via zIndex\n        popupCount = parseInt(node.style.zIndex) - 1000;\n      }\n      // Next Parent\n      node = node.parentNode;\n    }\n    // Create info object\n    var info = {\n      popupLevel: popupCount || 0,\n      isHandle: isHandle,\n    };\n    return info;\n  };\n\n  /*\n  Hijack core handleEvent\n  */\n  Popup.prototype.handleEvent = function (event) {\n    if (event.type === 'click') {\n      // Find out what was clicked on\n      var info = this.popupInfo(event.target),\n        cancelLevel = info.popupLevel - 1;\n      // Don't remove the level that was clicked on if we clicked on a handle\n      if (info.isHandle) {\n        if (cancelLevel < 0) {\n          cancelLevel = 1;\n        } else {\n          cancelLevel++;\n        }\n      }\n      // Cancel\n      this.cancel(cancelLevel);\n    }\n  };\n\n  // Hijack readPopupState of core reveal widget to set zIndex\n  Reveal.prototype.refresh = function () {\n    var domNode,\n      result,\n      wasOpen = this.isOpen;\n    // Run core handler\n    result = refreshCoreReveal.apply(this, arguments);\n    // Reference to domNode\n    domNode = this.domNodes[0];\n    if (\n      // If the popup is now open AND\n      this.isOpen &&\n      // It was not before\n      (wasOpen !== this.isOpen ||\n        // Or does not have a zIndex\n        !domNode.style.zIndex) &&\n      // AND\n      // There actually is a domNode AND\n      domNode &&\n      // This is a popup reveal OR\n      (this.type === 'popup' ||\n        // It's a dropdown-reveal\n        ($tw.utils.hasClass(domNode, 'tc-block-dropdown') && $tw.utils.hasClass(domNode, 'tc-reveal')))\n    ) {\n      // Dynamically set z-index\n      domNode.style.zIndex = 1000 + $tw.popup.popups.length;\n    }\n    return result;\n  };\n})();\n","type":"application/javascript","module-type":"utils"},"$:/plugins/tobibeer/appear/readme":{"title":"$:/plugins/tobibeer/appear/readme","text":"This plugin provides the ''$appear'' widget that can render popups and sliders (inline or block) as well as accordion menus.\n\n!! Attributes\n; type\n: set to `popup` to have the content appear as a popup\n; show\n: the button label\n; hide\n: the hide button label\n; mode\n: either `block` or `inline`, with respect to the inner content\n: any other mode is interpreted as block mode, without the default styles applying, e.g. drop-shadows\n; once\n: allows to click the button once, then hides it (unless the state is deleted)\n; $state\n: the widget calculates a state for you, use this to append a simple id\n; state\n: alternatively, specify a fully qualified state\n; keep\n: make popups sticky when `yes` or `true`\n; handle / handler / variables\n: allows to take the popup contents out of the flow and render them elsewhere on the page\n: required to properly create popups in table cells and other constained elements\n: specify variables to take along\n\n<br>\n\n; documentation / examples / demos...\n: http://tobibeer.github.io/tw5-plugins#appear\n"},"$:/plugins/tobibeer/appear/styles":{"title":"$:/plugins/tobibeer/appear/styles","tags":"$:/tags/Stylesheet","text":"\\rules only filteredtranscludeinline transcludeinline macrodef macrocallinline html\n\n<pre>.tc-reveal.appear-block,\n.tc-popup.appear {\n\tborder-radius: 5px;\n\tpadding: 1px 1em;\n\t<<box-shadow \"2px 2px 4px rgba(0,0,0,0.3)\">>;\n}\n.tc-popup.appear {\n\tpadding: 0 1em;\n\tbackground: <<colour background>>;\n}\n.appear-reveal.appear-inline{\nmargin-left:5px;\n}\n.appear-reveal.appear-inline.appear-once{\nmargin-left:0;\n}</pre>"}}}